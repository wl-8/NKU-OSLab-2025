# 操作系统lab1: 
# 比麻雀更小的麻雀（最小可执行内核）
## 一、练习 1：理解内核启动中的程序入口操作

阅读 kern/init/entry.S内容代码，结合操作系统内核启动流程，说明

1. 指令 `la sp, bootstacktop` 完成了什么操作，目的是什么？ 
2. 指令 `tail kern_init` 完成了什么操作，目的是什么？

### 1.操作系统内核启动流程

通过实验指导书我们知道，最小可执行内核的完整启动流程为:

加电复位 → CPU从`0x1000`进入MROM → 跳转到`0x80000000(OpenSBI)` → OpenSBI初始化并加载内核到`0x80200000` → 跳转到`entry.S` → 调用`kern_init()` → 输出信息 → 结束

因此我们知道，最小可执行内核在经过第一阶段的从复位地址`0x1000`加载bootloader:`OpenSBI`并跳转到`0x80000000`,再经过第二阶段的OpenSBI固件初始化、加载内核镜像到`0x80200000`,来到第三阶段初始,首先运行的就是entry.S中的内容。

更细一步的，我们在第二阶段中要加载内核镜像时，首先通过构造的链接脚本`kernel.ld`来确保将编译后的文件映射成为我们手动定义好每个`section`段之后的可执行内核镜像(.elf文件),其中就定义了`ENTRY(kern_entry)`，并且在对应映射section段时，把输入中的kern_entry这一段放到输出中text段的开头，也就是放在了整个内核映像文件的开头`0x80200000`处，因此对应着第三阶段首先运行的指令就是`kern_entry`这段指令。

### 2.指令 la sp, bootstacktop 完成了什么操作，目的是什么？

`la sp, bootstacktop`: 这是一条 RISC-V 汇编指令,将 `bootstacktop`的​​地址值​​加载到栈指针寄存器`sp`中。其中`sp`是 RISC-V 的​​栈指针寄存器,它指向当前栈的栈顶(高地址)。而`bootstacktop`是后面定义在 .data段的一个符号，代表内核栈的​​顶部地址​​（高地址）。在.data段中，首先通过`.align PGSHIFT`将下面数据的起始地址对齐到下面一张新页的开头(每页为4096B)，然后在定义符号`bootstack`之后，通过`.space KSTACKSIZE`指在当前地址（bootstack:）之后预留了2个4KB的连续内存空间，最后又定义了符号`bootstacktop`的位置，紧挨着位于这片连续空间之后。

因此这样我们就可以知道，留出的这片2个4KB的连续内存空间就是作为内核栈，`bootstack`的地址值就代表了内核栈空间的​​起始地址​​（低地址），`bootstacktop`的地址值就代表了内核栈空间的​​结束地址​​（高地址）。因此将内核栈的顶部地址赋给栈指针寄存器`sp`，是为了后续`kenl_init()`函数提供C函数调用所需要的栈空间，用来传递参数、保存返回地址和局部变量等。

### 3.指令 `tail kern_init` 完成了什么操作，目的是什么？

`tail kern_init`:同样是一条 RISC-V 汇编指令，用于执行一个​​尾调用​​，但这个调用`tail`意味着没有预期返回，这也与我们第三阶段中直接将控制权交给内核镜像相符，不需要返回，减少了保存返回地址的开销。因此相当于是跳转到`kern_init()`函数进行执行。


## 二、练习2：理解内核启动中的程序入口操作

使用 GDB 跟踪 QEMU 模拟的 RISC-V，从加电开始，直到执行内核第一条指令（跳转到 0x80200000）的整个过程。通过调试，请思考并回答：

1. RISC-V 硬件加电后最初执行的几条指令位于什么地址？
2. 它们主要完成了哪些功能？

请在报告中简要记录你的**调试过程**、**观察结果**和**问题的答案**。

### 1.调试过程与观察结果

#### (1)首先启动QEMU的debug，并连接GDB调试

在左侧终端运行如下命令，启动QEMU并暂停在初始状态：
```bash
make debug
```

在右侧终端运行如下命令，启动GDB并连接到QEMU：
```bash
make gdb
```

运行后显示:
```bash
The target architecture is set to "riscv:rv64".
Remote debugging using localhost:1234
0x0000000000001000 in ?? ()
(gdb) 
```

这表示现在程序停在了地址`0x1000`这个地方，即程序计数器`pc`位于`0x1000`，这是QEMU内置的固件（BIOS）代码。这说明加电后最初执行的指令位于地址`​​0x1000`​​。这也是QEMU虚拟机的复位地址。

#### (2)查看复位地址的几条初始指令​​：
以指令形式显示该复位地址后的10条指令。
```bash
(gdb) x/10i $pc
```
结果为:

```bash
(gdb) x/10i $pc
=> 0x1000:      auipc   t0,0x0
   0x1004:      addi    a2,t0,40
   0x1008:      csrr    a0,mhartid
   0x100c:      ld      a1,32(t0)
   0x1010:      ld      t0,24(t0)
   0x1014:      jr      t0
   0x1018:      unimp
   0x101a:      .insn   2, 0x8000
   0x101c:      unimp
   0x101e:      unimp
(gdb) 
```
这些从`0x1000`开始的指令是 OpenSBI 的​​引导代码，负责初始化硬件和设置运行环境。

#### (3)单步执行OpenSBI代码​​：
使用`si`命令单步执行指令，观察执行过程：
```bash
(gdb) si
```
重复执行si多次，跟踪指令流。结果如下:

```bash
(gdb) si
0x0000000000001004 in ?? ()
(gdb) si
0x0000000000001008 in ?? ()
(gdb) si
0x000000000000100c in ?? ()
(gdb) si
0x0000000000001010 in ?? ()
(gdb) si
0x0000000000001014 in ?? ()
(gdb) si
0x0000000080000000 in ?? ()
(gdb) si
0x0000000080000004 in ?? ()
(gdb) si
0x0000000080000008 in ?? ()
(gdb) si
0x000000008000000c in ?? ()
(gdb) si
0x0000000080000578 in ?? ()
(gdb) 
```
从上面的单步执行结果可以看到一些的启动流程：
```bash
0x1000 → 0x1004 → 0x1008 → 0x100c → 0x1010 → 0x1014
```
CPU 从复位地址`0x1000`开始执行初始化固件`OpenSBI`的引导代码，负责最基本的初始化与跳转到`0x80000000`地址
```bash
0x1014: jr t0 → 跳转到 0x80000000
```
这条指令跳转到了 0x80000000，这是 OpenSBI 主程序的起始地址。后续会进行OpenSBI的初始化与加载内核。
```bash
0x80000000 → 0x80000004 → 0x80000008 → 0x8000000c → ...
```
这是 OpenSBI 的主要初始化代码，硬件设备初始化（串口、定时器等）、内存管理单元（MMU）设置、异常和中断处理设置等。

#### (4)设置断点
```bash
(gdb) b *0x80000000                # OpenSBI 主程序开始处
Breakpoint 1 at 0x80000000

(gdb) b *0x80200000                # 内核入口点
Breakpoint 2 at 0x80200000: file kern/init/entry.S, line 7.
```

#### (5)设置 watchpoint 观察内核加载

```bash
(gdb) watch *0x80200000            # 监视内核加载地址
Hardware watchpoint 3: *0x80200000
```
#### (6)continue开始执行并观察
执行到在第二个断点`0x80200000`处
```bash
Breakpoint 2, kern_entry () at kern/init/entry.S:7
7           la sp, bootstacktop
```
执行
```bash
(gdb) disassemble kern_entry       # 反汇编内核入口函数
```
结果为：
```bash
(gdb) disassemble kern_entry
Dump of assembler code for function kern_entry:
=> 0x0000000080200000 <+0>:     auipc   sp,0x3
   0x0000000080200004 <+4>:     mv      sp,sp
   0x0000000080200008 <+8>:     j       0x8020000a <kern_init>
End of assembler dump.
```
可以看出来，此处`0x80000000`的反汇编代码，对应的就是我们`entry.S`中的`kern_entry`代码段，这也验证了我们第三阶段的将控制权交给内核映像。


### 问题答案

**问题1**

RISC-V 硬件加电后，PC 设置为 `0x1000` 复位向量地址，CPU 跳转到该处开始执行复位代码，即最初的几条指令地址就是 `0x1000` 处开始的。

**问题2**

CPU 从复位地址`0x1000`开始执行初始化固件`OpenSBI`的引导代码，负责最基本的初始化与跳转到`0x80000000`地址。跳转到`0x80000000`地址后，进行OpenSBI的主要初始化，最后进行加载内核映像的工作。

